# distutils: language=c++
# cython: language_level=3

from tube cimport Tube
import cython
from libc.math cimport pi, sqrt, abs, copysign


cpdef double foo():
    """функция для тестов
    
    Returns:
        [type] -- [description]
    """
    cdef Tube t = Tube([1,2,3],[3,3,3])
    cdef double d = t.get_d(4)
    return d

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef inline void roue_to_q_(
    double ro,
    double u,
    double e,
    double[:] q):

    q[0] = ro
    q[1] = ro * u
    q[2] = ro * (e + 0.5 * u * u)

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef inline (double, double, double) q_to_roue(double[:] q):
    cdef double ro = q[0]
    cdef double u = q[1] / q[0]
    cdef double e = q[2] / q[0] - 0.5 * u * u
    return ro, u, e

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef inline double roe_to_p(
    double ro,
    double e,
    double gamma,
    double b):

    return (gamma-1)*e*ro/(1-b*ro)


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef inline double rop_to_e(
    double ro,
    double p,
    double gamma,
    double b):

    return p*(1/ro-b)/(gamma-1)

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef inline double rop_to_csound(
    double ro,
    double p,
    double gamma,
    double b):

    return sqrt(p / ((1/gamma) * ro * (1 - b*ro)))


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef (double, double, double) AUSM_gas_(
    double p1, 
    double ro1, 
    double u1, 
    double e1, 
    double c1,
    double p2, 
    double ro2, 
    double u2, 
    double e2, 
    double c2,
    double vbi):

    cdef double r1=ro1
    cdef double r2=ro2
    cdef double H1 = e1 + 0.5*u1*u1 + p1/r1
    cdef double H2 = e2 + 0.5*u2*u2 + p2/r2

    cdef double cs = 0.5*(c1+c2)
    cdef double Mr1 = (u1-vbi)/cs
    cdef double Mr2 = (u2-vbi)/cs

    # ! Vacuum solution (?)
    # uvac = 2.0*g(4)*cs - du
    # if (uvac <= 0) then
    #     write(*,*) "Vacuum generated by given data"
    #     return
    # end if

    cdef double M4p, P5p, M4m, P5m
    if abs(Mr1) >= 1.0 :
        M4p = 0.5*(Mr1+abs(Mr1))
        P5p = 0.5*(Mr1+abs(Mr1))/Mr1    
    else:
        M4p = 0.25*((Mr1+1.0)*(Mr1+1.0))*(1.0+2.0*0.25*(Mr1-1.0)*(Mr1-1.0))
        P5p = 0.25*((Mr1+1.0)*(Mr1+1.0))*((2.0-Mr1)+3.0*Mr1*0.25*(Mr1-1.0)*(Mr1-1.0))   

    if abs(Mr2) >= 1.0:
        M4m = 0.5*(Mr2-abs(Mr2))
        P5m = 0.5*(Mr2-abs(Mr2))/Mr2
    else:
        M4m = -0.25*((Mr2-1.0)*(Mr2-1.0))*(1.0+2.0*0.25*(Mr2+1.0)*(Mr2+1.0))
        P5m = 0.25*((Mr2-1.0)*(Mr2-1.0))*((2.0+Mr2)-3.0*Mr2*0.25*(Mr2+1.0)*(Mr2+1.0))
    
    cdef double phi1 = 1.0
    cdef double phi2 = 1.0
    cdef double Mrf = M4p + M4m
    cdef double pf = P5p*phi1*p1 + P5m*phi2*p2

    cdef double flux1 = 0.5*(cs*Mrf*(phi1*r1+phi2*r2)-cs*abs(Mrf)*(phi2*r2-phi1*r1))
    cdef double flux2 = copysign(0.5*(cs*Mrf*(phi1*r1*u1+phi2*r2*u2)-cs*abs(Mrf)*(phi2*r2*u2-phi1*r1*u1)) + pf, Mrf)
    cdef double flux3 = 0.5*(cs*Mrf*(phi1*r1*H1+phi2*r2*H2)-cs*abs(Mrf)*(phi2*r2*H2-phi1*r1*H1)) + pf*vbi

    return flux1, flux2, flux3

cdef class GasLayer(object):
    def __init__(self):
        pass

    
