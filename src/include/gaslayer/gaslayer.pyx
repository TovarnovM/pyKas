# distutils: language=c++
# cython: language_level=3, boundscheck=False, nonecheck=False, cdivision=True, initializedcheck=False

from tube cimport Tube
import cython
from libc.math cimport pi, sqrt, abs, copysign, abs
from godunov cimport get_e_13_1, get_p_13_1, get_c_13_8, mega_foo_cython, get_ray_URP
import numpy as np
# cimport numpy as np


cpdef double foo():
    """функция для тестов
    
    Returns:
        [type] -- [description]
    """
    cdef Tube t = Tube([1,2,3],[3,3,3])
    cdef double d = t.get_d(4)
    return d

cpdef inline void roue_to_q_(
    double ro,
    double u,
    double e,
    double[:] q):

    q[0] = ro
    q[1] = ro * u
    q[2] = ro * (e + 0.5 * u * u)


cpdef inline (double, double, double) q_to_roue(double[:] q):
    cdef double ro = q[0]
    cdef double u = q[1] / q[0]
    cdef double e = q[2] / q[0] - 0.5 * u * u
    return ro, u, e


cpdef inline double roe_to_p(
    double ro,
    double e,
    double gamma,
    double b):

    return (gamma-1)*e*ro/(1-b*ro)



cpdef inline double rop_to_e(
    double ro,
    double p,
    double gamma,
    double b):

    return p*(1/ro-b)/(gamma-1)


cpdef inline double rop_to_csound(
    double ro,
    double p,
    double gamma,
    double b):

    return sqrt(p / ((1/gamma) * ro * (1 - b*ro)))



cpdef (double, double, double) AUSM_gas_(
    double p1, 
    double ro1, 
    double u1, 
    double e1, 
    double c1,
    double p2, 
    double ro2, 
    double u2, 
    double e2, 
    double c2,
    double vbi):

    cdef double r1=ro1
    cdef double r2=ro2
    cdef double H1 = e1 + 0.5*u1*u1 + p1/r1
    cdef double H2 = e2 + 0.5*u2*u2 + p2/r2

    cdef double cs = 0.5*(c1+c2)
    cdef double Mr1 = (u1-vbi)/cs
    cdef double Mr2 = (u2-vbi)/cs

    # ! Vacuum solution (?)
    # uvac = 2.0*g(4)*cs - du
    # if (uvac <= 0) then
    #     write(*,*) "Vacuum generated by given data"
    #     return
    # end if

    cdef double M4p, P5p, M4m, P5m
    if abs(Mr1) >= 1.0 :
        M4p = 0.5*(Mr1+abs(Mr1))
        P5p = 0.5*(Mr1+abs(Mr1))/Mr1    
    else:
        M4p = 0.25*((Mr1+1.0)*(Mr1+1.0))*(1.0+2.0*0.25*(Mr1-1.0)*(Mr1-1.0))
        P5p = 0.25*((Mr1+1.0)*(Mr1+1.0))*((2.0-Mr1)+3.0*Mr1*0.25*(Mr1-1.0)*(Mr1-1.0))   

    if abs(Mr2) >= 1.0:
        M4m = 0.5*(Mr2-abs(Mr2))
        P5m = 0.5*(Mr2-abs(Mr2))/Mr2
    else:
        M4m = -0.25*((Mr2-1.0)*(Mr2-1.0))*(1.0+2.0*0.25*(Mr2+1.0)*(Mr2+1.0))
        P5m = 0.25*((Mr2-1.0)*(Mr2-1.0))*((2.0+Mr2)-3.0*Mr2*0.25*(Mr2+1.0)*(Mr2+1.0))
    
    cdef double phi1 = 1.0
    cdef double phi2 = 1.0
    cdef double Mrf = M4p + M4m
    cdef double pf = P5p*phi1*p1 + P5m*phi2*p2

    cdef double flux1 = 0.5*(cs*Mrf*(phi1*r1+phi2*r2)-cs*abs(Mrf)*(phi2*r2-phi1*r1))
    cdef double flux2 = copysign(0.5*(cs*Mrf*(phi1*r1*u1+phi2*r2*u2)-cs*abs(Mrf)*(phi2*r2*u2-phi1*r1*u1)) + pf, Mrf)
    cdef double flux3 = 0.5*(cs*Mrf*(phi1*r1*H1+phi2*r2*H2)-cs*abs(Mrf)*(phi2*r2*H2-phi1*r1*H1)) + pf*vbi

    return flux1, flux2, flux3


cdef class GasEOS(object):
    def __init__(self, gamma, kappa=0.0, p_0=0.0, c_0=0.0, kind=1):
        self.gamma = gamma
        self.kappa = kappa
        self.p_0 = p_0
        self.c_0 = c_0
        self.kind = kind

    cpdef double get_e(self, double ro, double p):
        if self.kind == 1:
            return rop_to_e(ro, p, self.gamma, self.kappa)
        else:
            return get_e_13_1(p, ro, self.p_0, self.c_0, self.gamma)

    cpdef double get_p(self, double ro, double e):
        if self.kind == 1:
            return roe_to_p(ro, e, self.gamma, self.kappa)
        else:
            return get_p_13_1(e, ro, self.p_0, self.c_0, self.gamma)

    cpdef double get_csound(self, double ro, double p):
        if self.kind == 1:
            return rop_to_csound(ro, p, self.gamma, self.kappa)
        else:
            return get_c_13_8(p, ro, self.p_0, self.gamma)


cdef class GasLayer(object):
    def __init__(self, n_cells, tube, gasEOS):
        self.tube = tube
        self.gasEOS = gasEOS
        self.time = 0

        self.xs_cells = np.zeros(n_cells, dtype=np.double)
        self.xs_borders = np.zeros(n_cells+1, dtype=np.double)
        self.Vs_borders = np.zeros(n_cells+1, dtype=np.double)

        self.S = np.zeros(n_cells+1, dtype=np.double)

        self.ds = np.zeros(n_cells, dtype=np.double)
        self.W = np.zeros(n_cells, dtype=np.double)

        self.ps = np.zeros(n_cells, dtype=np.double)
        self.ros = np.zeros(n_cells, dtype=np.double)
        self.us = np.zeros(n_cells, dtype=np.double)
        self.es = np.zeros(n_cells, dtype=np.double)

        self.flux1 = np.zeros(n_cells+1, dtype=np.double)
        self.flux2 = np.zeros(n_cells+1, dtype=np.double)
        self.flux3 = np.zeros(n_cells+1, dtype=np.double)

        self.q1 = np.zeros(n_cells, dtype=np.double)
        self.q2 = np.zeros(n_cells, dtype=np.double)
        self.q3 = np.zeros(n_cells, dtype=np.double)

    cpdef GasLayer copy(self):
        cdef GasLayer res = GasLayer(self.n_cells, self.tube, self.gasEOS)
        res.time = self.time

        res.xs_cells[:] = self.xs_cells
        res.xs_borders[:] = self.xs_borders
        res.Vs_borders[:] = self.Vs_borders

        res.S[:] = self.S 

        res.ds[:] = self.ds
        res.W[:] = self.W

        res.ps[:] = self.ps
        res.ros[:] = self.ros
        res.us[:] = self.us
        res.es[:] = self.es

        res.flux1[:] = self.flux1
        res.flux2[:] = self.flux2
        res.flux3[:] = self.flux3

        res.q1[:] = self.q1
        res.q2[:] = self.q2
        res.q3[:] = self.q3
        return res


    def init_with_foo(self):
        pass
    

